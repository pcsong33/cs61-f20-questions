Kernel question
===============
It is the year 2025, and Intel has just introduced its Frosty Ice Cream Ocean processors, which is the first architecture to implement a 6-level page table. 
Q1. Compared to a 4-level page table, adding two additional levels increases the address space by what factor? Assume that the size of a page and the number of entries per page is the same as in a standard x86-64 architecture.
A. 512 * 512 = 2^18. Adding an additional level multiplies the address space by the number of entries per page, which is 512. 
Q2. What is the main drawback of having 6-level page table? Why don't we just implement 10-level page tables, or 20-level page tables?
A. The main drawback is that adding additional levels makes page table "walks" longer, making memory access longer. For example, in a 6-level page table, in worst case scenario, translating a virtual address may require the processor to access physical memory 7 times (once for each of the six levels, and once for the final translated physical address).
Q3. Due to the failure of their Frosty Ice Cream Ocean processors, Intel has lost all of their market share to AMD. Thus, they have pivoted to a "back to the basics" approach using a 2-level page table architecture with the following specifications:
Page Size: 16 KiB (16,384 bytes)
Virtual Address Size: 38 bits
Page Table Entry Size: 8 bytes
However, none of Intel's systems engineers have taken CS61 (all of the smart ones have been hired by AMD), and they need your help deriving the rest of the 2-level page specifications.
1. How many bits are required for the offset? 14 bits. 16,384 bytes = 2^14, thus 14-bits are needed to represent every possible offset
2. How many page table entries are needed in total? 2^38 / 2^14 = 2^24
3. How many page table entries can fit in a page? 2^14 / 2^3 = 2^11
4. How should the virtual address be split up into its three components (L1 index, L2 index, offset12)? 
12 bits | 12 bits | 14 bits 






